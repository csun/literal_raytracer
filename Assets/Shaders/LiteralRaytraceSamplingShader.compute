#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl" // for TEXTURE2D_X() and RW_TEXTURE2D_X

#pragma kernel CSMain
#define MAX_RAYS 256

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> _ColorAndTotals;

float3 _SSRayStarts[MAX_RAYS];
float3 _SSRayDeltas[MAX_RAYS];
float3 _RayColors[MAX_RAYS];
int _RayCount;


[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
	float3 avgColor = _ColorAndTotals[id.xy].xyz;
	float totalLuminance = _ColorAndTotals[id.xy].a;
	// By default, camera depth is reversed (0 is far plane, 1 is near plane)
	float sceneDepth = 1 - LoadCameraDepth(id.xy);

	for (int i = 0; i < _RayCount; i++)
	{
		float2 relativePoint = id.xy - _SSRayStarts[i].xy;

		// The ratio of total ray length that makes up the projection of our pixel onto it.
		float ratio = dot(relativePoint, _SSRayDeltas[i].xy) / pow(length(_SSRayDeltas[i].xy), 2);
		// Clamp so that we don't draw any points that are beyond the ends of the line segment
		ratio = clamp(ratio, 0, 1);

		float3 linePoint = (ratio * _SSRayDeltas[i]) + _SSRayStarts[i];

		// Draw if this pixel is on the line and the line is in front of other objects in scene
		uint3 roundedLinePoint = round(linePoint);
		bool shouldDraw = (roundedLinePoint.x == id.x) &&
			(roundedLinePoint.y == id.y) &&
			(linePoint.z < sceneDepth) &&
			(linePoint.z >= 0);

		float currentLuminance = shouldDraw * length(_RayColors[i]);
		float prevTotalLuminance = totalLuminance;
		totalLuminance += currentLuminance;

		float3 candidateColor = ((_RayColors[i] * currentLuminance) + (avgColor * prevTotalLuminance)) / totalLuminance;

		avgColor = shouldDraw ? candidateColor : avgColor;
	}

	_ColorAndTotals[id.xy] = float4(avgColor, totalLuminance);
}
